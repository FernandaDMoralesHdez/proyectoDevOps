import os
import sqlite3
import json
import re
from datetime import datetime

class SecurityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.report_path = "security/reports"

    def scan_system(self):
        self._check_database_security()
        self._check_api_endpoints()
        self._check_client_side_security()
        self._check_data_validation()
        self._generate_report()

    def _check_database_security(self):
        try:
            # Check database file permissions
            if os.path.exists("db/temperaturas.db"):
                permissions = os.stat("db/temperaturas.db")
                if permissions.st_mode & 0o777 == 0o777:
                    self.vulnerabilities.append({
                        "severity": "HIGH",
                        "type": "Database Security",
                        "description": "Database file has too permissive access rights",
                        "recommendation": "Restrict database file permissions"
                    })

            # Check for SQL injection vulnerabilities
            self._check_sql_injection_vulnerabilities()
        except Exception as e:
            self.vulnerabilities.append({
                "severity": "ERROR",
                "type": "Database Check",
                "description": f"Error checking database security: {str(e)}",
                "recommendation": "Verify database configuration and permissions"
            })

    def _check_sql_injection_vulnerabilities(self):
        try:
            risky_patterns = [
                r"SELECT .* FROM",   # Busca consultas SELECT
                r"DELETE FROM",      # DELETE sin protección
                r"UPDATE .* SET",    # UPDATE vulnerable
                r"DROP TABLE",       # DROP peligroso
                r"TRUNCATE TABLE"    # Truncate sin control
            ]

            vulnerable_files = []

            for root, _, files in os.walk("."):  # Recorre todo el proyecto
                for file in files:
                    if file.endswith(".py"):  # Solo archivos Python
                        file_path = os.path.join(root, file)
                        with open(file_path, "r", encoding="utf-8") as f:
                            content = f.read()

                            # Busca palabras clave SQL sin placeholders
                            for pattern in risky_patterns:
                                if re.search(pattern, content, re.IGNORECASE) and "?" not in content:
                                    vulnerable_files.append(file_path)
                                    break  # No necesitamos analizar más si ya lo marcamos

                            # Detecta concatenaciones en queries SQL
                            if re.search(r"execute\((?:f|\"|\').*?[\+\{\}].*?\)", content):
                                vulnerable_files.append(file_path)

            if vulnerable_files:
                self.vulnerabilities.append({
                    "severity": "HIGH",
                    "type": "SQL Injection Risk",
                    "description": f"Possible SQL injection vulnerabilities in {', '.join(set(vulnerable_files))}",
                    "recommendation": "Use parameterized queries (cursor.execute('SELECT * FROM table WHERE id = ?', (id,)))"
                })

        except Exception as e:
            self.vulnerabilities.append({
                "severity": "ERROR",
                "type": "SQL Injection Check",
                "description": f"Error checking SQL injection vulnerabilities: {str(e)}",
                "recommendation": "Review database query implementation"
            })

    def _check_api_endpoints(self):
        # Check for unsecured endpoints
        unsecured_endpoints = [
            "/api/temperatures",
            "/api/metrics/average_temperature",
            "/metrics/history"
        ]
        
        self.vulnerabilities.append({
            "severity": "MEDIUM",
            "type": "API Security",
            "description": f"Unsecured API endpoints found: {', '.join(unsecured_endpoints)}",
            "recommendation": "Implement authentication for sensitive endpoints"
        })

    def _check_client_side_security(self):
        # Check for potential XSS vulnerabilities in frontend code
        if os.path.exists("static/script.js"):
            try:
                # Try UTF-8 first
                with open("static/script.js", "r", encoding="utf-8") as f:
                    js_content = f.read()
            except UnicodeDecodeError:
                # Fallback to latin-1 if UTF-8 fails
                with open("static/script.js", "r", encoding="latin-1") as f:
                    js_content = f.read()
                    
            if "innerHTML" in js_content:
                self.vulnerabilities.append({
                    "severity": "MEDIUM",
                    "type": "XSS Vulnerability",
                    "description": "Direct innerHTML usage found which could lead to XSS attacks",
                    "recommendation": "Use textContent or sanitize HTML content"
                })

    def _check_data_validation(self):
        # Check for input validation
        self.vulnerabilities.append({
            "severity": "LOW",
            "type": "Input Validation",
            "description": "Temperature data lacks input validation",
            "recommendation": "Implement proper validation for temperature values"
        })

    def _generate_report(self):
        report = {
            "scan_timestamp": datetime.now().isoformat(),
            "total_vulnerabilities": len(self.vulnerabilities),
            "vulnerabilities": self.vulnerabilities
        }

        filename = f"security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        filepath = os.path.join(self.report_path, filename)
        
        with open(filepath, "w") as f:
            json.dump(report, f, indent=2)
        
        print(f"Security scan complete. Report saved to {filepath}")